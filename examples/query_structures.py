#!/usr/bin/env python3
"""Query and download structures from MinIO by biological criteria.

Requires:
  1. A manifest parquet generated by download_pdb.py
  2. MINIO_* env vars configured (or .env file)

Usage:
    # Fetch human kinases (Pfam PF00069, ≤2.5 Å)
    python examples/query_structures.py --manifest manifests/pdb.parquet --collection kinases_human

    # Fetch by Pfam family
    python examples/query_structures.py --manifest manifests/pdb.parquet --pfam PF00069 --resolution 2.5 --max 200

    # Fetch by EC number
    python examples/query_structures.py --manifest manifests/pdb.parquet --ec 2.7.10 --max 100

    # Fetch specific PDB IDs
    python examples/query_structures.py --manifest manifests/pdb.parquet --ids 1abc,2xyz,3def

    # List available collections
    python examples/query_structures.py --list-collections
"""

from __future__ import annotations

import argparse
import logging

from moldata.query import MinIOQuery, list_collections

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(name)s - %(message)s")


def main() -> None:
    p = argparse.ArgumentParser(description="Query structures from MinIO")
    p.add_argument("--manifest", default="manifests/pdb.parquet", help="Path to manifest parquet")
    p.add_argument("--cache-dir", default="/moldata/query_cache", help="Local cache for downloaded files")
    p.add_argument("--workers", type=int, default=8, help="Parallel download workers")

    g = p.add_mutually_exclusive_group()
    g.add_argument("--collection", help="Pre-defined collection name (e.g. kinases_human)")
    g.add_argument("--pfam", help="Pfam family ID (e.g. PF00069)")
    g.add_argument("--ec", help="EC number (e.g. 2.7.10)")
    g.add_argument("--go", help="GO term (e.g. GO:0004672)")
    g.add_argument("--taxonomy", type=int, help="NCBI taxonomy ID (e.g. 9606)")
    g.add_argument("--keyword", help="Free-text keyword")
    g.add_argument("--ids", help="Comma-separated PDB IDs")
    g.add_argument("--list-collections", action="store_true", help="List available collections")

    p.add_argument("--resolution", type=float, default=3.0, help="Max resolution (Å)")
    p.add_argument("--max", type=int, default=500, help="Max structures to fetch")
    args = p.parse_args()

    if args.list_collections:
        print(f"{'Name':<25} {'Description':<55} {'Tags'}")
        print("-" * 100)
        for c in list_collections():
            tags = ", ".join(c.tags)
            print(f"{c.name:<25} {c.description:<55} {tags}")
        return

    q = MinIOQuery(manifest_path=args.manifest, cache_dir=args.cache_dir, workers=args.workers)
    print(f"Manifest: {q.count()} structures")

    if args.collection:
        paths = q.fetch_collection(args.collection, max_structures=args.max, resolution_max=args.resolution)
    elif args.pfam:
        paths = q.fetch_by_family(args.pfam, max_structures=args.max, resolution_max=args.resolution)
    elif args.ec:
        paths = q.fetch_by_ec(args.ec, max_structures=args.max, resolution_max=args.resolution)
    elif args.go:
        paths = q.fetch_by_go(args.go, max_structures=args.max, resolution_max=args.resolution)
    elif args.taxonomy is not None:
        paths = q.fetch_by_taxonomy(args.taxonomy, max_structures=args.max, resolution_max=args.resolution)
    elif args.keyword:
        paths = q.fetch_by_keyword(args.keyword, max_structures=args.max, resolution_max=args.resolution)
    elif args.ids:
        id_list = [x.strip() for x in args.ids.split(",") if x.strip()]
        paths = q.fetch(id_list, max_structures=args.max)
    else:
        p.print_help()
        return

    print(f"\nDownloaded {len(paths)} structures to {args.cache_dir}")
    if paths:
        print(f"  First: {paths[0]}")
        print(f"  Last:  {paths[-1]}")


if __name__ == "__main__":
    main()
